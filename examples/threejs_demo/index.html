<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>plato three.js demo</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="three.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="QuickHull.js"></script>
    <script src="ConvexGeometry.js"></script>
    <script>
      httpRequest = new XMLHttpRequest();
      httpRequest.onreadystatechange = function() {
        if (httpRequest.readyState === XMLHttpRequest.DONE) {
          if (httpRequest.status === 200) {
            jsondata = JSON.parse(httpRequest.responseText);
            console.log(jsondata);
            drawScene(jsondata);
            animate();
          } else {
            alert('There was a problem with the request.');
          }
        }
      };
      httpRequest.open('GET', '3.json', true);
      httpRequest.send();

      var scene, camera, renderer, controls;

      var makeColor = function(c) {
        return new THREE.Color(c[0], c[1], c[2]);
      }

      var makeVec3 = function(v) {
        return new THREE.Vector3(v[0], v[1], v[2]);
      }

      var makeFace3 = function(f) {
        return new THREE.Face3(f[0], f[1], f[2]);
      }

      var makeQuat = function(q) {
        // Converts from (w, x, y, z) to (x, y, z, w) order.
        return new THREE.Quaternion(q[1], q[2], q[3], q[0]);
      }

      var drawScene = function(jsonscene) {
        scene = new THREE.Scene();
        scene.background = makeColor([1, 1, 1]);

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 );
        camera.position.z = 10;

        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 1.5;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', render );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        for (var prim of jsonscene.primitives) {
          var pa = prim.attributes;
          console.debug("Creating " + prim.class + "...");
          if (prim.class == 'Spheres') {
            for (var [position, color, radius] of pa.positions.map(
                  (e, i) => [e, pa.colors[i], pa.radii[i]] )) {
              var geometry = new THREE.SphereGeometry(radius);
              var material = new THREE.MeshBasicMaterial({color: makeColor(color)});
              var shape = new THREE.Mesh(geometry, material);
              shape.position.x = position[0];
              shape.position.y = position[1];
              shape.position.z = position[2];
              scene.add(shape);
            }
          } else if (prim.class == 'Lines') {
            for (var [start, end, color, width] of pa.start_points.map(
                  (e, i) => [e, pa.end_points[i], pa.colors[i], pa.widths[i]] )) {
              var geometry = new THREE.Geometry();
              geometry.vertices.push(makeVec3(start));
              geometry.vertices.push(makeVec3(end));
              var material = new THREE.LineBasicMaterial({color: makeColor(color)});
              var shape = new THREE.Line(geometry, material);
              scene.add(shape);
            }
          } else if (prim.class == 'Mesh') {
            var geometry = new THREE.Geometry();
            for (var v of pa.vertices.map((e) => makeVec3(e))) {
              geometry.vertices.push(v);
            }
            for (var f of pa.indices.map((e) => makeFace3(e))) {
              geometry.faces.push(f);
            }
            for (var color of pa.colors) {
              var material = new THREE.MeshBasicMaterial({color: makeColor(color)});
              var shape = new THREE.Mesh(geometry, material);
              scene.add(shape);
            }

          } else if (prim.class == 'ConvexPolyhedra') {
            vertices = pa.vertices.map((e) => makeVec3(e));
            var geometry = new THREE.ConvexGeometry(vertices);
            for (var [position, orientation, color] of pa.positions.map(
                  (e, i) => [e, pa.orientations[i], pa.colors[i]] )) {
              var material = new THREE.MeshBasicMaterial({color: makeColor(color)});
              var shape = new THREE.Mesh(geometry, material);
              shape.position.x = position[0];
              shape.position.y = position[1];
              shape.position.z = position[2];
              // TODO: Orientations are wrong
              shape.applyQuaternion(makeQuat(orientation));
              scene.add(shape);
            }
          } else if (prim.class == 'ConvexSpheropolyhedra') {
            // TODO: This doesn't render spheroshapes yet, just ConvexPolyhedra
            radius = pa.radius;
            vertices = pa.vertices.map((e) => makeVec3(e));
            var geometry = new THREE.ConvexGeometry(vertices);
            for (var [position, orientation, color] of pa.positions.map(
                  (e, i) => [e, pa.orientations[i], pa.colors[i]] )) {
              var material = new THREE.MeshBasicMaterial({color: makeColor(color)});
              var shape = new THREE.Mesh(geometry, material);
              shape.position.x = position[0];
              shape.position.y = position[1];
              shape.position.z = position[2];
              // TODO: Orientations are wrong
              shape.applyQuaternion(makeQuat(orientation));
              scene.add(shape);
            }
         } else {
            console.error("Primitive " + prim.class + " is not supported.");
            console.log(prim);
          }
        }

        window.addEventListener( 'resize', onWindowResize, false );

        render();
      };

      var onWindowResize = function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
        render();
      };

      var animate = function () {
        requestAnimationFrame( animate );
        controls.update();
      };

      var render = function() {
        renderer.render( scene, camera );
      };
    </script>
  </body>
</html>
